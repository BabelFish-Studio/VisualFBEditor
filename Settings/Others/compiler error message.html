<html>
<head>
<code><title>Compiler</title></code>
<link rel="stylesheet" type="text/css" href="style.css">
<meta charset="UTF-8">
</head>
<body>
<div id="fb_body_wrapper">
<div id="fb_tab">
<code><div id="fb_tab_l">Compiler error message</div></code>
<div id="fb_tab_r">&nbsp;</div> 
</div> 
<div id="fb_pg_wrapper">
<div id="fb_pg_body">
<div class="freebasic">
<li><code>...' ellipsis upper bound given for array field (this is not supported)&nbsp;=&nbsp;</code>...' ellipsis upper bound given for array field (this is not supported)<br \>
<li><code>...' ellipsis upper bound given for dynamic array (this is not supported)&nbsp;=&nbsp;</code>...' ellipsis upper bound given for dynamic array (this is not supported)<br \>
<li><code>~' parsed as equality operator in function argument, not assignment to BYREF function result&nbsp;=&nbsp;</code>~' parsed as equality operator in function argument, not assignment to BYREF function result<br \>
<li><code>A destructor should not have any parameters&nbsp;=&nbsp;</code>A destructor should not have any parameters<br \>
<li><code>ABSTRACT used here, but not the in the DECLARE statement&nbsp;=&nbsp;</code>ABSTRACT used here, but not the in the DECLARE statement<br \>
<li><code>ABSTRACT used on non-member procedure&nbsp;=&nbsp;</code>=B6<br \>
<li><code>Accessing base UDT's private default constructor&nbsp;=&nbsp;</code>Accessing base UDT's private default constructor<br \>
<li><code>Accessing base UDT's private destructor&nbsp;=&nbsp;</code>Accessing base UDT's private destructor<br \>
<li><code>ALIAS name here does not match ALIAS given in DECLARE prototype&nbsp;=&nbsp;</code>ALIAS name here does not match ALIAS given in DECLARE prototype<br \>
<li><code>ALIAS name string is empty&nbsp;=&nbsp;</code>ALIAS name string is empty<br \>
<li><code>Ambiguous call to overloaded function&nbsp;=&nbsp;</code>Ambiguous call to overloaded function<br \>
<li><code>Ambiguous symbol access, explicit scope resolution required&nbsp;=&nbsp;</code>Ambiguous symbol access, explicit scope resolution required<br \>
<li><code>An ENUM, TYPE or UNION cannot be empty&nbsp;=&nbsp;</code>An ENUM, TYPE or UNION cannot be empty<br \>
<li><code>Argument count mismatch&nbsp;=&nbsp;</code>Argument count mismatch<br \>
<li><code>Array access, index expected&nbsp;=&nbsp;</code>Array access, index expected<br \>
<li><code>Array already dimensioned&nbsp;=&nbsp;</code>Array already dimensioned<br \>
<li><code>Array boundaries do not match the original EXTERN declaration&nbsp;=&nbsp;</code>Array boundaries do not match the original EXTERN declaration<br \>
<li><code>Array not dimensioned&nbsp;=&nbsp;</code>Array not dimensioned<br \>
<li><code>Array of references - not supported yet&nbsp;=&nbsp;</code>Array of references - not supported yet<br \>
<li><code>Array out-of-bounds&nbsp;=&nbsp;</code>Array out-of-bounds<br \>
<li><code>Array too big&nbsp;=&nbsp;</code>Array too big<br \>
<li><code>Array too large for stack, consider making it var-len or SHARED&nbsp;=&nbsp;</code>Array too large for stack, consider making it var-len or SHARED<br \>
<li><code>Arrays are not allowed&nbsp;=&nbsp;</code>Arrays are not allowed<br \>
<li><code>-asm att used for -gen gas, but -gen gas only supports -asm intel&nbsp;=&nbsp;</code>-asm att used for -gen gas, but -gen gas only supports -asm intel<br \>
<li><code>-asm att|intel option given, but not supported for this target (only x86 or x86_64)&nbsp;=&nbsp;</code>-asm att|intel option given, but not supported for this target (only x86 or x86_64)<br \>
<li><code>At least one parameter must be a user-defined type&nbsp;=&nbsp;</code>At least one parameter must be a user-defined type<br \>
<li><code>at parameter&nbsp;=&nbsp;</code>at parameter<br \>
<li><code>Auto variables are only valid in -lang&nbsp;=&nbsp;</code>Auto variables are only valid in -lang<br \>
<li><code>BASE() initializer not at top of constructor&nbsp;=&nbsp;</code>BASE() initializer not at top of constructor<br \>
<li><code>Both parameters can't be of the same type&nbsp;=&nbsp;</code>Both parameters can't be of the same type<br \>
<li><code>Branch crossing local array, var-len string or object definition&nbsp;=&nbsp;</code>Branch crossing local array, var-len string or object definition<br \>
<li><code>Branch crossing local variable definition&nbsp;=&nbsp;</code>Branch crossing local variable definition<br \>
<li><code>Branching to other functions or to module-level&nbsp;=&nbsp;</code>Branching to other functions or to module-level<br \>
<li><code>Branching to scope block containing local variables&nbsp;=&nbsp;</code>Branching to scope block containing local variables<br \>
<li><code>Byref function result not set&nbsp;=&nbsp;</code>Byref function result not set<br \>
<li><code>Calling convention does not match DECLARE prototype&nbsp;=&nbsp;</code>Calling convention does not match DECLARE prototype<br \>
<li><code>Cannot export symbol without -export option&nbsp;=&nbsp;</code>Cannot export symbol without -export option<br \>
<li><code>Cannot modify a constant&nbsp;=&nbsp;</code>Cannot modify a constant<br \>
<li><code>Cannot pop stack, underflow&nbsp;=&nbsp;</code>Cannot pop stack, underflow<br \>
<li><code>Can't use ... as lower bound&nbsp;=&nbsp;</code>Can't use ... as lower bound<br \>
<li><code>Can't use ANY as initializer in array with ellipsis bound&nbsp;=&nbsp;</code>Can't use ANY as initializer in array with ellipsis bound<br \>
<li><code>CASE without SELECT&nbsp;=&nbsp;</code>CASE without SELECT<br \>
<li><code>Cast to non-pointer&nbsp;=&nbsp;</code>Cast to non-pointer<br \>
<li><code>Casting derived UDT pointer from incompatible pointer type&nbsp;=&nbsp;</code>Casting derived UDT pointer from incompatible pointer type<br \>
<li><code>Casting derived UDT pointer from unrelated UDT pointer type&nbsp;=&nbsp;</code>Casting derived UDT pointer from unrelated UDT pointer type<br \>
<li><code>Casting derived UDT pointer to incompatible pointer type&nbsp;=&nbsp;</code>Casting derived UDT pointer to incompatible pointer type<br \>
<li><code>Casting derived UDT pointer to unrelated UDT pointer type&nbsp;=&nbsp;</code>Casting derived UDT pointer to unrelated UDT pointer type<br \>
<li><code>CLASS, TYPE or UNION has no constructor&nbsp;=&nbsp;</code>CLASS, TYPE or UNION has no constructor<br \>
<li><code>CLASS, TYPE or UNION not derived&nbsp;=&nbsp;</code>CLASS, TYPE or UNION not derived<br \>
<li><code>Cloning operators (LET, Copy constructors) can't take a byval arg of the parent's type&nbsp;=&nbsp;</code>Cloning operators (LET, Copy constructors) can't take a byval arg of the parent's type<br \>
<li><code>Command line option overrides directive&nbsp;=&nbsp;</code>Command line option overrides directive<br \>
<li><code>COMMON variables cannot be object instances of CLASS/TYPE's with cons/destructors&nbsp;=&nbsp;</code>COMMON variables cannot be object instances of CLASS/TYPE's with cons/destructors<br \>
<li><code>Const UDT cannot invoke non-const method&nbsp;=&nbsp;</code>Const UDT cannot invoke non-const method<br \>
<li><code>CONST used here, but not the in the DECLARE statement&nbsp;=&nbsp;</code>CONST used here, but not the in the DECLARE statement<br \>
<li><code>CONST used on constructor (not needed)&nbsp;=&nbsp;</code>CONST used on constructor (not needed)<br \>
<li><code>CONST used on destructor (not needed)&nbsp;=&nbsp;</code>CONST used on destructor (not needed)<br \>
<li><code>CONST used on non-member procedure&nbsp;=&nbsp;</code>CONST used on non-member procedure<br \>
<li><code>Constant declared in anonymous UDT&nbsp;=&nbsp;</code>Constant declared in anonymous UDT<br \>
<li><code>Constructor declared ABSTRACT&nbsp;=&nbsp;</code>Constructor declared ABSTRACT<br \>
<li><code>Constructor declared VIRTUAL&nbsp;=&nbsp;</code>Constructor declared VIRTUAL<br \>
<li><code>Constructor has no public access&nbsp;=&nbsp;</code>Constructor has no public access<br \>
<li><code>CONSTRUCTOR() chain call not at top of constructor&nbsp;=&nbsp;</code>CONSTRUCTOR() chain call not at top of constructor<br \>
<li><code>Declaration outside the original namespace&nbsp;=&nbsp;</code>Declaration outside the original namespace<br \>
<li><code>Declaration outside the original namespace or class&nbsp;=&nbsp;</code>Declaration outside the original namespace or class<br \>
<li><code>Default types or suffixes are only valid in -lang&nbsp;=&nbsp;</code>Default types or suffixes are only valid in -lang<br \>
<li><code>Default types or suffixes are only valid in -lang deprecated or fblite or qb&nbsp;=&nbsp;</code>Default types or suffixes are only valid in -lang deprecated or fblite or qb<br \>
<li><code>Deleting ANY pointers is undefined&nbsp;=&nbsp;</code>Deleting ANY pointers is undefined<br \>
<li><code>Destructor declared ABSTRACT&nbsp;=&nbsp;</code>Destructor declared ABSTRACT<br \>
<li><code>Destructor has no public access&nbsp;=&nbsp;</code>Destructor has no public access<br \>
<li><code>Directive ignored after first pass&nbsp;=&nbsp;</code>Directive ignored after first pass<br \>
<li><code>Division by zero&nbsp;=&nbsp;</code>Division by zero<br \>
<li><code>Duplicated definition&nbsp;=&nbsp;</code>Duplicated definition<br \>
<li><code>Dynamic arrays cannot be part of UNION's or nested TYPE's&nbsp;=&nbsp;</code>Dynamic arrays cannot be part of UNION's or nested TYPE's<br \>
<li><code>Dynamic arrays can't be const&nbsp;=&nbsp;</code>Dynamic arrays can't be const<br \>
<li><code>Element not defined&nbsp;=&nbsp;</code>Element not defined<br \>
<li><code>Elements must be empty for strings and arrays&nbsp;=&nbsp;</code>Elements must be empty for strings and arrays<br \>
<li><code>ELSE without IF&nbsp;=&nbsp;</code>ELSE without IF<br \>
<li><code>ELSEIF without IF&nbsp;=&nbsp;</code>ELSEIF without IF<br \>
<li><code>END EXTERN without EXTERN&nbsp;=&nbsp;</code>END EXTERN without EXTERN<br \>
<li><code>END IF without IF&nbsp;=&nbsp;</code>END IF without IF<br \>
<li><code>END NAMESPACE without NAMESPACE&nbsp;=&nbsp;</code>END NAMESPACE without NAMESPACE<br \>
<li><code>END SCOPE without SCOPE&nbsp;=&nbsp;</code>END SCOPE without SCOPE<br \>
<li><code>END SELECT without SELECT&nbsp;=&nbsp;</code>END SELECT without SELECT<br \>
<li><code>END SUB or FUNCTION without SUB or FUNCTION&nbsp;=&nbsp;</code>END SUB or FUNCTION without SUB or FUNCTION<br \>
<li><code>END WITH without WITH&nbsp;=&nbsp;</code>END WITH without WITH<br \>
<li><code>ENUM's declared inside EXTERN .. END EXTERN blocks don't open new scopes&nbsp;=&nbsp;</code>ENUM's declared inside EXTERN .. END EXTERN blocks don't open new scopes<br \>
<li><code>ERASE on UDT with non-CDECL constructor&nbsp;=&nbsp;</code>ERASE on UDT with non-CDECL constructor<br \>
<li><code>ERASE on UDT with non-CDECL destructor&nbsp;=&nbsp;</code>ERASE on UDT with non-CDECL destructor<br \>
<li><code>ERASE on UDT with non-parameterless default constructor&nbsp;=&nbsp;</code>ERASE on UDT with non-parameterless default constructor<br \>
<li><code>Executable not found&nbsp;=&nbsp;</code>Executable not found<br \>
<li><code>Expected '-'&nbsp;=&nbsp;</code>Expected '-'<br \>
<li><code>Expected '#ENDIF'&nbsp;=&nbsp;</code>Expected '#ENDIF'<br \>
<li><code>Expected '('&nbsp;=&nbsp;</code>Expected '('<br \>
<li><code>Expected ')'&nbsp;=&nbsp;</code>Expected ')'<br \>
<li><code>Expected ','&nbsp;=&nbsp;</code>Expected ','<br \>
<li><code>Expected ':'&nbsp;=&nbsp;</code>Expected ':'<br \>
<li><code>Expected ';'&nbsp;=&nbsp;</code>Expected ';'<br \>
<li><code>Expected ']'&nbsp;=&nbsp;</code>Expected ']'<br \>
<li><code>Expected '{'&nbsp;=&nbsp;</code>Expected '{'<br \>
<li><code>Expected '}'&nbsp;=&nbsp;</code>Expected '}'<br \>
<li><code>Expected '~'&nbsp;=&nbsp;</code>Expected '~'<br \>
<li><code>Expected '~'&nbsp;=&nbsp;</code>Expected '~'<br \>
<li><code>Expected '>'&nbsp;=&nbsp;</code>Expected '>'<br \>
<li><code>Expected a CLASS, TYPE or UNION symbol type&nbsp;=&nbsp;</code>Expected a CLASS, TYPE or UNION symbol type<br \>
<li><code>Expected 'ANY'&nbsp;=&nbsp;</code>Expected 'ANY'<br \>
<li><code>Expected array&nbsp;=&nbsp;</code>Expected array<br \>
<li><code>Expected 'AS'&nbsp;=&nbsp;</code>Expected 'AS'<br \>
<li><code>Expected 'CASE'&nbsp;=&nbsp;</code>Expected 'CASE'<br \>
<li><code>Expected class or UDT identifier&nbsp;=&nbsp;</code>Expected class or UDT identifier<br \>
<li><code>Expected constant&nbsp;=&nbsp;</code>Expected constant<br \>
<li><code>Expected 'CONSTRUCTOR', 'DESTRUCTOR', 'DO', 'FOR', 'FUNCTION', 'OPERATOR', 'PROPERTY', 'SELECT', 'SUB' or 'WHILE'&nbsp;=&nbsp;</code>Expected 'CONSTRUCTOR', 'DESTRUCTOR', 'DO', 'FOR', 'FUNCTION', 'OPERATOR', 'PROPERTY', 'SELECT', 'SUB' or 'WHILE'<br \>
<li><code>Expected 'DO'&nbsp;=&nbsp;</code>Expected 'DO'<br \>
<li><code>Expected 'DO', 'FOR' or 'WHILE'&nbsp;=&nbsp;</code>Expected 'DO', 'FOR' or 'WHILE'<br \>
<li><code>Expected 'END ASM'&nbsp;=&nbsp;</code>Expected 'END ASM'<br \>
<li><code>Expected 'END CONSTRUCTOR'&nbsp;=&nbsp;</code>Expected 'END CONSTRUCTOR'<br \>
<li><code>Expected 'END DESTRUCTOR'&nbsp;=&nbsp;</code>Expected 'END DESTRUCTOR'<br \>
<li><code>Expected 'END ENUM'&nbsp;=&nbsp;</code>Expected 'END ENUM'<br \>
<li><code>Expected 'END EXTERN'&nbsp;=&nbsp;</code>Expected 'END EXTERN'<br \>
<li><code>Expected 'END FUNCTION'&nbsp;=&nbsp;</code>Expected 'END FUNCTION'<br \>
<li><code>Expected 'END IF'&nbsp;=&nbsp;</code>Expected 'END IF'<br \>
<li><code>Expected 'END NAMESPACE'&nbsp;=&nbsp;</code>Expected 'END NAMESPACE'<br \>
<li><code>Expected 'END OPERATOR'&nbsp;=&nbsp;</code>Expected 'END OPERATOR'<br \>
<li><code>Expected 'END PROPERTY'&nbsp;=&nbsp;</code>Expected 'END PROPERTY'<br \>
<li><code>Expected 'END SCOPE'&nbsp;=&nbsp;</code>Expected 'END SCOPE'<br \>
<li><code>Expected 'END SELECT'&nbsp;=&nbsp;</code>Expected 'END SELECT'<br \>
<li><code>Expected 'END SUB'&nbsp;=&nbsp;</code>Expected 'END SUB'<br \>
<li><code>Expected 'END SUB' or 'END FUNCTION'&nbsp;=&nbsp;</code>Expected 'END SUB' or 'END FUNCTION'<br \>
<li><code>Expected 'END TYPE' or 'END UNION'&nbsp;=&nbsp;</code>Expected 'END TYPE' or 'END UNION'<br \>
<li><code>Expected 'END WITH'&nbsp;=&nbsp;</code>Expected 'END WITH'<br \>
<li><code>Expected 'ENDMACRO'&nbsp;=&nbsp;</code>Expected 'ENDMACRO'<br \>
<li><code>Expected End-of-File&nbsp;=&nbsp;</code>Expected End-of-File<br \>
<li><code>Expected End-of-Line&nbsp;=&nbsp;</code>Expected End-of-Line<br \>
<li><code>Expected explicit result type&nbsp;=&nbsp;</code>Expected explicit result type<br \>
<li><code>Expected expression&nbsp;=&nbsp;</code>Expected expression<br \>
<li><code>Expected 'FOR'&nbsp;=&nbsp;</code>Expected 'FOR'<br \>
<li><code>Expected identifier&nbsp;=&nbsp;</code>Expected identifier<br \>
<li><code>Expected initializer&nbsp;=&nbsp;</code>Expected initializer<br \>
<li><code>Expected 'LOOP'&nbsp;=&nbsp;</code>Expected 'LOOP'<br \>
<li><code>Expected 'NEXT'&nbsp;=&nbsp;</code>Expected 'NEXT'<br \>
<li><code>Expected operator&nbsp;=&nbsp;</code>Expected operator<br \>
<li><code>Expected period ('.')&nbsp;=&nbsp;</code>Expected period ('.')<br \>
<li><code>Expected pointer&nbsp;=&nbsp;</code>Expected pointer<br \>
<li><code>Expected 'PROPERTY'&nbsp;=&nbsp;</code>Expected 'PROPERTY'<br \>
<li><code>Expected 'PTR' or 'POINTER'&nbsp;=&nbsp;</code>Expected 'PTR' or 'POINTER'<br \>
<li><code>Expected relational operator ( ~, >, <, <>, <~, >~ )&nbsp;=&nbsp;</code>Expected relational operator ( ~, >, <, <>, <~, >~ )<br \>
<li><code>Expected scalar counter&nbsp;=&nbsp;</code>Expected scalar counter<br \>
<li><code>Expected 'SELECT'&nbsp;=&nbsp;</code>Expected 'SELECT'<br \>
<li><code>Expected sub&nbsp;=&nbsp;</code>Expected sub<br \>
<li><code>Expected 'THEN'&nbsp;=&nbsp;</code>Expected 'THEN'<br \>
<li><code>Expected 'TO'&nbsp;=&nbsp;</code>Expected 'TO'<br \>
<li><code>Expected var-len array&nbsp;=&nbsp;</code>Expected var-len array<br \>
<li><code>Expected 'WEND'&nbsp;=&nbsp;</code>Expected 'WEND'<br \>
<li><code>Expected 'WHILE'&nbsp;=&nbsp;</code>Expected 'WHILE'<br \>
<li><code>EXTERN or COMMON dynamic arrays cannot have initial bounds&nbsp;=&nbsp;</code>EXTERN or COMMON dynamic arrays cannot have initial bounds<br \>
<li><code>EXTERN or COMMON variables cannot be initialized&nbsp;=&nbsp;</code>EXTERN or COMMON variables cannot be initialized<br \>
<li><code>Fields cannot be named as keywords in TYPE's that contain member functions or in CLASS'es&nbsp;=&nbsp;</code>Fields cannot be named as keywords in TYPE's that contain member functions or in CLASS'es<br \>
<li><code>Fields with constructors cannot be part of UNION's or nested TYPE's&nbsp;=&nbsp;</code>Fields with constructors cannot be part of UNION's or nested TYPE's<br \>
<li><code>Fields with destructors cannot be part of UNION's or nested TYPE's&nbsp;=&nbsp;</code>Fields with destructors cannot be part of UNION's or nested TYPE's<br \>
<li><code>File access error&nbsp;=&nbsp;</code>File access error<br \>
<li><code>Fixed-len strings cannot be returned from functions&nbsp;=&nbsp;</code>Fixed-len strings cannot be returned from functions<br \>
<li><code>Fixed-length string combined with BYREF (not supported)&nbsp;=&nbsp;</code>Fixed-length string combined with BYREF (not supported)<br \>
<li><code>FOR/NEXT variable name mismatch&nbsp;=&nbsp;</code>FOR/NEXT variable name mismatch<br \>
<li><code>Forward references not allowed&nbsp;=&nbsp;</code>Forward references not allowed<br \>
<li><code>FreeBasic Compiler&nbsp;=&nbsp;</code>FreeBasic Compiler<br \>
<li><code>FUNCTION ~' or EXIT FUNCTION mixed with RETURN (using both styles together is unsupported when returning objects with constructors)&nbsp;=&nbsp;</code>FUNCTION ~' or EXIT FUNCTION mixed with RETURN (using both styles together is unsupported when returning objects with constructors)<br \>
<li><code>Function not declared&nbsp;=&nbsp;</code>Function not declared<br \>
<li><code>Function result assignment outside of the function&nbsp;=&nbsp;</code>Function result assignment outside of the function<br \>
<li><code>Function result TYPE has no default constructor&nbsp;=&nbsp;</code>Function result TYPE has no default constructor<br \>
<li><code>Function result was not explicitly set&nbsp;=&nbsp;</code>Function result was not explicitly set<br \>
<li><code>GOSUB disabled, use 'OPTION GOSUB' to enable&nbsp;=&nbsp;</code>GOSUB disabled, use 'OPTION GOSUB' to enable<br \>
<li><code>Identifier cannot include periods&nbsp;=&nbsp;</code>Identifier cannot include periods<br \>
<li><code>Identifier's name too big, truncated&nbsp;=&nbsp;</code>Identifier's name too big, truncated<br \>
<li><code>'IF' statement found directly after multi-line 'ELSE'&nbsp;=&nbsp;</code>'IF' statement found directly after multi-line 'ELSE'<br \>
<li><code>Illegal 'END'&nbsp;=&nbsp;</code>Illegal 'END'<br \>
<li><code>Illegal inside a compound statement or scoped block&nbsp;=&nbsp;</code>Illegal inside a compound statement or scoped block<br \>
<li><code>Illegal inside a NAMESPACE block&nbsp;=&nbsp;</code>Illegal inside a NAMESPACE block<br \>
<li><code>Illegal inside functions&nbsp;=&nbsp;</code>Illegal inside functions<br \>
<li><code>Illegal member access&nbsp;=&nbsp;</code>Illegal member access<br \>
<li><code>Illegal non-static member access&nbsp;=&nbsp;</code>Illegal non-static member access<br \>
<li><code>Illegal outside a CLASS, TYPE or UNION method&nbsp;=&nbsp;</code>Illegal outside a CLASS, TYPE or UNION method<br \>
<li><code>Illegal outside a compound statement&nbsp;=&nbsp;</code>Illegal outside a compound statement<br \>
<li><code>Illegal outside a CONSTRUCTOR block&nbsp;=&nbsp;</code>Illegal outside a CONSTRUCTOR block<br \>
<li><code>Illegal outside a CONSTRUCTOR, DESTRUCTOR, FUNCTION, OPERATOR, PROPERTY or SUB block&nbsp;=&nbsp;</code>Illegal outside a CONSTRUCTOR, DESTRUCTOR, FUNCTION, OPERATOR, PROPERTY or SUB block<br \>
<li><code>Illegal outside a DESTRUCTOR block&nbsp;=&nbsp;</code>Illegal outside a DESTRUCTOR block<br \>
<li><code>Illegal outside a DO compound statement&nbsp;=&nbsp;</code>Illegal outside a DO compound statement<br \>
<li><code>Illegal outside a FOR compound statement&nbsp;=&nbsp;</code>Illegal outside a FOR compound statement<br \>
<li><code>Illegal outside a FUNCTION block&nbsp;=&nbsp;</code>Illegal outside a FUNCTION block<br \>
<li><code>Illegal outside a PROPERTY block&nbsp;=&nbsp;</code>Illegal outside a PROPERTY block<br \>
<li><code>Illegal outside a SELECT compound statement&nbsp;=&nbsp;</code>Illegal outside a SELECT compound statement<br \>
<li><code>Illegal outside a SUB block&nbsp;=&nbsp;</code>Illegal outside a SUB block<br \>
<li><code>Illegal outside a WHILE compound statement&nbsp;=&nbsp;</code>Illegal outside a WHILE compound statement<br \>
<li><code>Illegal outside an OPERATOR block&nbsp;=&nbsp;</code>Illegal outside an OPERATOR block<br \>
<li><code>Illegal specification&nbsp;=&nbsp;</code>Illegal specification<br \>
<li><code>Illegal without the -ex option&nbsp;=&nbsp;</code>Illegal without the -ex option<br \>
<li><code>Implemented body for an ABSTRACT method&nbsp;=&nbsp;</code>Implemented body for an ABSTRACT method<br \>
<li><code>Implicit conversion&nbsp;=&nbsp;</code>Implicit conversion<br \>
<li><code>Implicit destructor override would have different calling convention&nbsp;=&nbsp;</code>Implicit destructor override would have different calling convention<br \>
<li><code>Implicit LET operator override would have different calling convention&nbsp;=&nbsp;</code>Implicit LET operator override would have different calling convention<br \>
<li><code>Implicit variable allocation&nbsp;=&nbsp;</code>Implicit variable allocation<br \>
<li><code>Implicit variables are only valid in -lang&nbsp;=&nbsp;</code>Implicit variables are only valid in -lang<br \>
<li><code>Incompatible reference initializer&nbsp;=&nbsp;</code>Incompatible reference initializer<br \>
<li><code>Incomplete type&nbsp;=&nbsp;</code>Incomplete type<br \>
<li><code>Internal!&nbsp;=&nbsp;</code>Internal!<br \>
<li><code>Invalid array index&nbsp;=&nbsp;</code>Invalid array index<br \>
<li><code>Invalid array subscript&nbsp;=&nbsp;</code>Invalid array subscript<br \>
<li><code>Invalid assignment/conversion&nbsp;=&nbsp;</code>Invalid assignment/conversion<br \>
<li><code>Invalid bitfield&nbsp;=&nbsp;</code>Invalid bitfield<br \>
<li><code>Invalid CASE range, start value is greater than the end value&nbsp;=&nbsp;</code>Invalid CASE range, start value is greater than the end value<br \>
<li><code>Invalid character&nbsp;=&nbsp;</code>Invalid character<br \>
<li><code>Invalid command-line option&nbsp;=&nbsp;</code>Invalid command-line option<br \>
<li><code>Invalid data types&nbsp;=&nbsp;</code>Invalid data types<br \>
<li><code>Invalid initializer&nbsp;=&nbsp;</code>Invalid initializer<br \>
<li><code>Invalid -lang&nbsp;=&nbsp;</code>Invalid -lang<br \>
<li><code>Invalid parameter type, it must be the same as the parent TYPE/CLASS&nbsp;=&nbsp;</code>Invalid parameter type, it must be the same as the parent TYPE/CLASS<br \>
<li><code>Invalid priority attribute&nbsp;=&nbsp;</code>Invalid priority attribute<br \>
<li><code>Invalid result type for this operator&nbsp;=&nbsp;</code>Invalid result type for this operator<br \>
<li><code>Invalid size&nbsp;=&nbsp;</code>Invalid size<br \>
<li><code>LIB name string is empty&nbsp;=&nbsp;</code>LIB name string is empty<br \>
<li><code>Literal number too big, truncated&nbsp;=&nbsp;</code>Literal number too big, truncated<br \>
<li><code>Literal string too big, truncated&nbsp;=&nbsp;</code>Literal string too big, truncated<br \>
<li><code>Local symbols can't be referenced&nbsp;=&nbsp;</code>Local symbols can't be referenced<br \>
<li><code>LOOP without DO&nbsp;=&nbsp;</code>LOOP without DO<br \>
<li><code>Macro numbering&nbsp;=&nbsp;</code>Macro numbering<br \>
<li><code>Macro text too long&nbsp;=&nbsp;</code>Macro text too long<br \>
<li><code>Member cannot be static&nbsp;=&nbsp;</code>Member cannot be static<br \>
<li><code>Member isn't static&nbsp;=&nbsp;</code>Member isn't static<br \>
<li><code>Method declared ABSTRACT, but UDT does not extend OBJECT&nbsp;=&nbsp;</code>Method declared ABSTRACT, but UDT does not extend OBJECT<br \>
<li><code>Method declared in anonymous UDT&nbsp;=&nbsp;</code>Method declared in anonymous UDT<br \>
<li><code>Method declared VIRTUAL, but UDT does not extend OBJECT&nbsp;=&nbsp;</code>Method declared VIRTUAL, but UDT does not extend OBJECT<br \>
<li><code>Mismatching parameter initializer&nbsp;=&nbsp;</code>Mismatching parameter initializer<br \>
<li><code>Missing BASE() initializer (base UDT without default constructor requires manual initialization)&nbsp;=&nbsp;</code>Missing BASE() initializer (base UDT without default constructor requires manual initialization)<br \>
<li><code>Missing closing quote in literal string&nbsp;=&nbsp;</code>Missing closing quote in literal string<br \>
<li><code>Missing command-line option for&nbsp;=&nbsp;</code>Missing command-line option for<br \>
<li><code>Missing default constructor implementation (base UDT without default constructor requires manual initialization)&nbsp;=&nbsp;</code>Missing default constructor implementation (base UDT without default constructor requires manual initialization)<br \>
<li><code>Missing overloaded operator: &nbsp;=&nbsp;</code>Missing overloaded operator: <br \>
<li><code>Missing RETURN to copy-construct function result&nbsp;=&nbsp;</code>Missing RETURN to copy-construct function result<br \>
<li><code>Missing UDT.constructor(byref as const UDT) implementation (base UDT without default constructor requires manual initialization)&nbsp;=&nbsp;</code>Missing UDT.constructor(byref as const UDT) implementation (base UDT without default constructor requires manual initialization)<br \>
<li><code>Missing UDT.constructor(byref as UDT) implementation (base UDT without default constructor requires manual initialization)&nbsp;=&nbsp;</code>Missing UDT.constructor(byref as UDT) implementation (base UDT without default constructor requires manual initialization)<br \>
<li><code>Mixing signed/unsigned operands&nbsp;=&nbsp;</code>Mixing signed/unsigned operands<br \>
<li><code>Must have initializer with array with ellipsis bound&nbsp;=&nbsp;</code>Must have initializer with array with ellipsis bound<br \>
<li><code>NEXT without FOR&nbsp;=&nbsp;</code>NEXT without FOR<br \>
<li><code>No end of multi-line comment, expected ""'/""&nbsp;=&nbsp;</code>No end of multi-line comment, expected ""'/""<br \>
<li><code>No explicit BYREF or BYVAL&nbsp;=&nbsp;</code>No explicit BYREF or BYVAL<br \>
<li><code>No matching overloaded function&nbsp;=&nbsp;</code>No matching overloaded function<br \>
<li><code>No outer DO compound statement found&nbsp;=&nbsp;</code>No outer DO compound statement found<br \>
<li><code>No outer FOR compound statement found&nbsp;=&nbsp;</code>No outer FOR compound statement found<br \>
<li><code>No outer SELECT compound statement found&nbsp;=&nbsp;</code>No outer SELECT compound statement found<br \>
<li><code>No outer WHILE compound statement found&nbsp;=&nbsp;</code>No outer WHILE compound statement found<br \>
<li><code>Non-virtual call to ABSTRACT method&nbsp;=&nbsp;</code>Non-virtual call to ABSTRACT method<br \>
<li><code>Not extending a TYPE/UNION (a TYPE/UNION can only extend other TYPEs/UNIONs)&nbsp;=&nbsp;</code>Not extending a TYPE/UNION (a TYPE/UNION can only extend other TYPEs/UNIONs)<br \>
<li><code>Not overriding any virtual method&nbsp;=&nbsp;</code>Not overriding any virtual method<br \>
<li><code>-o <file> option without corresponding input file&nbsp;=&nbsp;</code>-o <file> option without corresponding input file<br \>
<li><code>Object files or libraries with mixed language (-lang) options&nbsp;=&nbsp;</code>Object files or libraries with mixed language (-lang) options<br \>
<li><code>Object files or libraries with mixed multithreading (-mt) options&nbsp;=&nbsp;</code>Object files or libraries with mixed multithreading (-mt) options<br \>
<li><code>Objects with default [con|de]structors or methods are only allowed in the module level&nbsp;=&nbsp;</code>Objects with default [con|de]structors or methods are only allowed in the module level<br \>
<li><code>Only data members supported&nbsp;=&nbsp;</code>Only data members supported<br \>
<li><code>Only static members can be accessed from static functions&nbsp;=&nbsp;</code>Only static members can be accessed from static functions<br \>
<li><code>Only valid in -lang&nbsp;=&nbsp;</code>Only valid in -lang<br \>
<li><code>Operator cannot be a member function&nbsp;=&nbsp;</code>Operator cannot be a member function<br \>
<li><code>Operator must be a member function&nbsp;=&nbsp;</code>Operator must be a member function<br \>
<li><code>Overflow in constant conversion&nbsp;=&nbsp;</code>Overflow in constant conversion<br \>
<li><code>Override has different calling convention than overridden method&nbsp;=&nbsp;</code>Override has different calling convention than overridden method<br \>
<li><code>Override has different parameters than overridden method&nbsp;=&nbsp;</code>Override has different parameters than overridden method<br \>
<li><code>Override has different return type than overridden method&nbsp;=&nbsp;</code>Override has different return type than overridden method<br \>
<li><code>Override is a CONST member, but the overridden method is not&nbsp;=&nbsp;</code>Override is a CONST member, but the overridden method is not<br \>
<li><code>Override is not a CONST member like the overridden method&nbsp;=&nbsp;</code>Override is not a CONST member like the overridden method<br \>
<li><code>Parameter and result can't be of the same type&nbsp;=&nbsp;</code>Parameter and result can't be of the same type<br \>
<li><code>Parameter cannot be optional&nbsp;=&nbsp;</code>Parameter cannot be optional<br \>
<li><code>Parameter must be a pointer&nbsp;=&nbsp;</code>Parameter must be a pointer<br \>
<li><code>Parameter must be an integer&nbsp;=&nbsp;</code>Parameter must be an integer<br \>
<li><code>Parameter or result must be a user-defined type&nbsp;=&nbsp;</code>Parameter or result must be a user-defined type<br \>
<li><code>Parameter type mismatch&nbsp;=&nbsp;</code>Parameter type mismatch<br \>
<li><code>Parent is not a class or UDT&nbsp;=&nbsp;</code>Parent is not a class or UDT<br \>
<li><code>Passing different pointer types&nbsp;=&nbsp;</code>Passing different pointer types<br \>
<li><code>Passing Pointer&nbsp;=&nbsp;</code>Passing Pointer<br \>
<li><code>Passing pointer to scalar&nbsp;=&nbsp;</code>Passing pointer to scalar<br \>
<li><code>Passing scalar as pointer&nbsp;=&nbsp;</code>Passing scalar as pointer<br \>
<li><code>Permission denied&nbsp;=&nbsp;</code>Permission denied<br \>
<li><code>-pic used when making executable (only works when making a shared library)&nbsp;=&nbsp;</code>-pic used when making executable (only works when making a shared library)<br \>
<li><code>-pic used, but not supported by target system (only works for non-x86 Unixes)&nbsp;=&nbsp;</code>-pic used, but not supported by target system (only works for non-x86 Unixes)<br \>
<li><code>Possible escape sequence found in&nbsp;=&nbsp;</code>Possible escape sequence found in<br \>
<li><code>Procedure macro numbering&nbsp;=&nbsp;</code>Procedure macro numbering<br \>
<li><code>PROPERTY GET should have no parameter, or just one if indexed&nbsp;=&nbsp;</code>PROPERTY GET should have no parameter, or just one if indexed<br \>
<li><code>PROPERTY has no GET method/accessor&nbsp;=&nbsp;</code>PROPERTY has no GET method/accessor<br \>
<li><code>PROPERTY has no indexed GET method/accessor&nbsp;=&nbsp;</code>PROPERTY has no indexed GET method/accessor<br \>
<li><code>PROPERTY has no indexed SET method/accessor&nbsp;=&nbsp;</code>PROPERTY has no indexed SET method/accessor<br \>
<li><code>PROPERTY has no SET method/accessor&nbsp;=&nbsp;</code>PROPERTY has no SET method/accessor<br \>
<li><code>PROPERTY SET should have one parameter, or just two if indexed&nbsp;=&nbsp;</code>PROPERTY SET should have one parameter, or just two if indexed<br \>
<li><code>Range too large&nbsp;=&nbsp;</code>Range too large<br \>
<li><code>Recursion level too deep&nbsp;=&nbsp;</code>Recursion level too deep<br \>
<li><code>Recursive DEFINE not allowed&nbsp;=&nbsp;</code>Recursive DEFINE not allowed<br \>
<li><code>Recursive TYPE or UNION not allowed&nbsp;=&nbsp;</code>Recursive TYPE or UNION not allowed<br \>
<li><code>Redefinition of intrinsic&nbsp;=&nbsp;</code>Redefinition of intrinsic<br \>
<li><code>REDIM on UDT with non-CDECL constructor&nbsp;=&nbsp;</code>REDIM on UDT with non-CDECL constructor<br \>
<li><code>REDIM on UDT with non-CDECL destructor&nbsp;=&nbsp;</code>REDIM on UDT with non-CDECL destructor<br \>
<li><code>REDIM on UDT with non-parameterless default constructor&nbsp;=&nbsp;</code>REDIM on UDT with non-parameterless default constructor<br \>
<li><code>Reference not initialized&nbsp;=&nbsp;</code>Reference not initialized<br \>
<li><code>Resource file given for target system that does not support them&nbsp;=&nbsp;</code>Resource file given for target system that does not support them<br \>
<li><code>Return method mismatch&nbsp;=&nbsp;</code>Return method mismatch<br \>
<li><code>RETURN mixed with 'FUNCTION ~' or EXIT FUNCTION (using both styles together is unsupported when returning objects with constructors)&nbsp;=&nbsp;</code>RETURN mixed with 'FUNCTION ~' or EXIT FUNCTION (using both styles together is unsupported when returning objects with constructors)<br \>
<li><code>Return type here does not match DECLARE prototype&nbsp;=&nbsp;</code>Return type here does not match DECLARE prototype<br \>
<li><code>Selected -gen gas ASM backend for non-x86 CPU&nbsp;=&nbsp;</code>Selected -gen gas ASM backend for non-x86 CPU<br \>
<li><code>Selected non-x86 CPU when compiling for DOS&nbsp;=&nbsp;</code>Selected non-x86 CPU when compiling for DOS<br \>
<li><code>Selected option requires an SSE FPU mode&nbsp;=&nbsp;</code>Selected option requires an SSE FPU mode<br \>
<li><code>Shift value greater than or equal to number of bits in data type&nbsp;=&nbsp;</code>Shift value greater than or equal to number of bits in data type<br \>
<li><code>Statement in between SELECT and first CASE&nbsp;=&nbsp;</code>Statement in between SELECT and first CASE<br \>
<li><code>Static member variable in nested UDT (only allowed in toplevel UDTs)&nbsp;=&nbsp;</code>Static member variable in nested UDT (only allowed in toplevel UDTs)<br \>
<li><code>STATIC used here, but not the in the DECLARE statement&nbsp;=&nbsp;</code>STATIC used here, but not the in the DECLARE statement<br \>
<li><code>STATIC used on non-member procedure&nbsp;=&nbsp;</code>STATIC used on non-member procedure<br \>
<li><code>Static variable declared in anonymous UDT&nbsp;=&nbsp;</code>Static variable declared in anonymous UDT<br \>
<li><code>'SUB' or 'FUNCTION' without 'END SUB' or 'END FUNCTION'&nbsp;=&nbsp;</code>'SUB' or 'FUNCTION' without 'END SUB' or 'END FUNCTION'<br \>
<li><code>Suffixes are only valid in -lang&nbsp;=&nbsp;</code>Suffixes are only valid in -lang<br \>
<li><code>Suspicious logic operation, mixed boolean and non-boolean operands&nbsp;=&nbsp;</code>Suspicious logic operation, mixed boolean and non-boolean operands<br \>
<li><code>Suspicious pointer assignment&nbsp;=&nbsp;</code>Suspicious pointer assignment<br \>
<li><code>Symbol not a CLASS, ENUM, TYPE or UNION type&nbsp;=&nbsp;</code>Symbol not a CLASS, ENUM, TYPE or UNION type<br \>
<li><code>Symbol type has no Run-Time Type Info (RTTI)&nbsp;=&nbsp;</code>Symbol type has no Run-Time Type Info (RTTI)<br \>
<li><code>Symbols defined inside namespaces cannot be removed&nbsp;=&nbsp;</code>Symbols defined inside namespaces cannot be removed<br \>
<li><code>Syntax error&nbsp;=&nbsp;</code>Syntax error<br \>
<li><code>The ANY initializer has no effect on UDT's with default constructors&nbsp;=&nbsp;</code>The ANY initializer has no effect on UDT's with default constructors<br \>
<li><code>The default constructor has no public access&nbsp;=&nbsp;</code>The default constructor has no public access<br \>
<li><code>the first parameter in a procedure may not be vararg&nbsp;=&nbsp;</code>the first parameter in a procedure may not be vararg<br \>
<li><code>The length of the parameters list is too large, consider passing UDT's BYREF&nbsp;=&nbsp;</code>The length of the parameters list is too large, consider passing UDT's BYREF<br \>
<li><code>The NEW operator cannot be used with fixed-length strings&nbsp;=&nbsp;</code>The NEW operator cannot be used with fixed-length strings<br \>
<li><code>The NEW[] operator does not allow explicit calls to constructors&nbsp;=&nbsp;</code>The NEW[] operator does not allow explicit calls to constructors<br \>
<li><code>The NEW[] operator only supports the { ANY } initialization&nbsp;=&nbsp;</code>The NEW[] operator only supports the { ANY } initialization<br \>
<li><code>The PRIVATE and PUBLIC attributes are not allowed with REDIM, COMMON or EXTERN&nbsp;=&nbsp;</code>The PRIVATE and PUBLIC attributes are not allowed with REDIM, COMMON or EXTERN<br \>
<li><code>The type length is too large, consider passing BYREF&nbsp;=&nbsp;</code>The type length is too large, consider passing BYREF<br \>
<li><code>This operator cannot be STATIC&nbsp;=&nbsp;</code>This operator cannot be STATIC<br \>
<li><code>This operator is implicitly STATIC and cannot be CONST&nbsp;=&nbsp;</code>This operator is implicitly STATIC and cannot be CONST<br \>
<li><code>This operator is implicitly STATIC and cannot be VIRTUAL or ABSTRACT&nbsp;=&nbsp;</code>This operator is implicitly STATIC and cannot be VIRTUAL or ABSTRACT<br \>
<li><code>This symbol cannot be undefined&nbsp;=&nbsp;</code>This symbol cannot be undefined<br \>
<li><code>Too many array dimensions&nbsp;=&nbsp;</code>Too many array dimensions<br \>
<li><code>Too many elements&nbsp;=&nbsp;</code>Too many elements<br \>
<li><code>Too many errors&nbsp;=&nbsp;</code>Too many errors<br \>
<li><code>Too many expressions&nbsp;=&nbsp;</code>Too many expressions<br \>
<li><code>Too many labels&nbsp;=&nbsp;</code>Too many labels<br \>
<li><code>Too many levels of pointer indirection&nbsp;=&nbsp;</code>Too many levels of pointer indirection<br \>
<li><code>Too many parameters&nbsp;=&nbsp;</code>Too many parameters<br \>
<li><code>Type mismatch&nbsp;=&nbsp;</code>Type mismatch<br \>
<li><code>Type mismatch in byref function result assignment&nbsp;=&nbsp;</code>Type mismatch in byref function result assignment<br \>
<li><code>TYPE or CLASS has no default constructor&nbsp;=&nbsp;</code>TYPE or CLASS has no default constructor<br \>
<li><code>Types have no hierarchical relation&nbsp;=&nbsp;</code>Types have no hierarchical relation<br \>
<li><code>UDT function results cannot be passed by reference&nbsp;=&nbsp;</code>UDT function results cannot be passed by reference<br \>
<li><code>UDT has unimplemented abstract methods&nbsp;=&nbsp;</code>UDT has unimplemented abstract methods<br \>
<li><code>UDT with pointer, var-len string, or var-len array fields&nbsp;=&nbsp;</code>UDT with pointer, var-len string, or var-len array fields<br \>
<li><code>UDT's containing var-len string fields cannot be initialized&nbsp;=&nbsp;</code>UDT's containing var-len string fields cannot be initialized<br \>
<li><code>UDT's with methods must have unique names&nbsp;=&nbsp;</code>UDT's with methods must have unique names<br \>
<li><code>Undefined label&nbsp;=&nbsp;</code>Undefined label<br \>
<li><code>Undefined symbol&nbsp;=&nbsp;</code>Undefined symbol<br \>
<li><code>UNIONs are not allowed&nbsp;=&nbsp;</code>UNIONs are not allowed<br \>
<li><code>Unsupported function&nbsp;=&nbsp;</code>Unsupported function<br \>
<li><code>Unsupported statement in -gen gcc mode&nbsp;=&nbsp;</code>Unsupported statement in -gen gcc mode<br \>
<li><code>User Defined Type too big&nbsp;=&nbsp;</code>User Defined Type too big<br \>
<li><code>Vararg parameters are not allowed in overloaded functions&nbsp;=&nbsp;</code>Vararg parameters are not allowed in overloaded functions<br \>
<li><code>vararg parameters are only allowed in CDECL procedures&nbsp;=&nbsp;</code>vararg parameters are only allowed in CDECL procedures<br \>
<li><code>Variable following NEXT is meaningless&nbsp;=&nbsp;</code>Variable following NEXT is meaningless<br \>
<li><code>Variable not declared&nbsp;=&nbsp;</code>Variable not declared<br \>
<li><code>Variable required&nbsp;=&nbsp;</code>Variable required<br \>
<li><code>Variable too large for stack, consider making it SHARED&nbsp;=&nbsp;</code>Variable too large for stack, consider making it SHARED<br \>
<li><code>Var-len arrays cannot be initialized&nbsp;=&nbsp;</code>Var-len arrays cannot be initialized<br \>
<li><code>Var-len strings cannot be initialized&nbsp;=&nbsp;</code>Var-len strings cannot be initialized<br \>
<li><code>Var-len strings cannot be part of UNION's or nested TYPE's&nbsp;=&nbsp;</code>Var-len strings cannot be part of UNION's or nested TYPE's<br \>
<li><code>VIRTUAL used here, but not the in the DECLARE statement&nbsp;=&nbsp;</code>VIRTUAL used here, but not the in the DECLARE statement<br \>
<li><code>VIRTUAL used on non-member procedure&nbsp;=&nbsp;</code>VIRTUAL used on non-member procedure<br \>
<li><code>WEND without WHILE&nbsp;=&nbsp;</code>WEND without WHILE<br \>
<li><code>Wrong number of dimensions&nbsp;=&nbsp;</code>Wrong number of dimensions<br \>

</div>
</div>
</div> 
</div> 

</body>
</html>
